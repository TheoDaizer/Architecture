import inspect

from types import FunctionType
from typing import Any, Type

from ioc.ioc_container import IoC


class AdapterGenerator:

    def __init__(self, interface: Type):
        self.interface = interface

    def generate(self):
        cls_name = self.interface.__name__
        members = inspect.getmembers(self.interface, predicate=inspect.isfunction)

        adapter_namespace: dict[str, Any] = {
            '__init__': lambda adapter, data_object: setattr(adapter, 'data_object', data_object)
        }

        for arg_name, value in members:
            if arg_name.startswith('__'):
                continue

            elif arg_name.startswith('get_'):
                key = arg_name.removeprefix('get_')
                dependency_name = f"{cls_name}:{key}.get"

                if self.keep_current_strategy(value):
                    dependency_resolve_strategy = value
                else:
                    dependency_resolve_strategy = self.default_get_strategy(key)

                IoC.resolve(
                    dependency='IoC.Register',
                    dependency_to_register=dependency_name,
                    dependency_resolve_strategy=dependency_resolve_strategy,
                ).execute()

                adapter_namespace[arg_name] = (
                    lambda dependency:
                    lambda adapter: IoC.resolve(
                        dependency, adapter=adapter
                    )
                )(dependency_name)

            elif arg_name.startswith('set_'):
                key = arg_name.removeprefix('set_')
                dependency_name = f"{cls_name}:{key}.set"

                if self.keep_current_strategy(value):
                    dependency_resolve_strategy = value
                else:
                    dependency_resolve_strategy = self.default_set_strategy(key)

                IoC.resolve(
                    dependency='IoC.Register',
                    dependency_to_register=dependency_name,
                    dependency_resolve_strategy=dependency_resolve_strategy,
                ).execute()

                adapter_namespace[arg_name] = (
                    lambda dependency: (
                        lambda adapter, new_value: IoC.resolve(
                            dependency, adapter=adapter, new_value=new_value
                        )
                    )
                )(dependency_name)

            else:
                dependency_name = f"{cls_name}:{arg_name}"

                if self.keep_current_strategy(value):
                    dependency_resolve_strategy = value
                else:
                    raise AttributeError(f'Unknown dependency {dependency_name}. '
                                         'Resolve strategy should be set with "_set_strategy_wrapper" decorator'
                                         )

                IoC.resolve(
                    dependency='IoC.Register',
                    dependency_to_register=dependency_name,
                    dependency_resolve_strategy=dependency_resolve_strategy,
                ).execute()

                adapter_namespace[arg_name] = (
                    lambda dependency: (
                        lambda adapter, **kwargs: IoC.resolve(dependency, adapter=adapter, **kwargs)
                    )
                )(dependency_name)


        return type(f'AutoGenerated.{cls_name}Adapter', (), adapter_namespace)

    @staticmethod
    def keep_current_strategy(current_strategy: Any):
        return isinstance(current_strategy, FunctionType) and current_strategy.__name__ == '_set_strategy_wrapper'

    @staticmethod
    def default_get_strategy(get_key: str):
        return lambda adapter: adapter.data_object[get_key]

    @staticmethod
    def default_set_strategy(set_key: str):
        return lambda adapter, new_value: adapter.data_object.__setitem__(set_key, new_value)
